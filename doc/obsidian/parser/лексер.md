## лексер (сканер)

Первая часть синтаксического анализатора, которая
- считывает текстовые файлы и строки, 
- разбивает их на группы символов,
- и преобразует эти группы в **токены**: структура включающая
	- строковое значение (*лексема*)
	- данные о имени файла исходного кода и строке/позиции в нём
	- тип токена, который далее используется в парсере

Для разбиения на группы можно использовать разные способы, чаще всего используется набор правил, задаваемых через регулярные выражения ([[regexp]]). Файл описания лексера в виде набора правил обрабатывается *генератором лексеров*, и получается автоматически сгенерированный код на одном из языков программирования. В зависимости от выбранного генератора, используются различные алгоритмы (вариации конечного автомата), а полученный код очень плохо читаем человеком даже в отладчике -- основная логика работы упаковывается в массивы, или развесистое дерево условных переходов.

![[ragel]]

## `src/skelex.lex`

Файл лексера для для генератора [[flex]]

### общая структура

```Cpp
%{
	// C++ код который будет вставлен в начало сгенерированного кода
%}

%option 	// опции генератора

%%			// обязательный маркер начала набора правил

<regexp>	{ /* C++ код */ }
...

// на забывайте пустую строку в конце .lex файла: характерная ошибка
```
необязательная часть:
```Cpp
%%			// второй маркер заканчивает блок regxep-правил

// далее идёт произвольный С++ код который будет скопирован в конец
```

### простые обработчики текстовых файлов

Возможность добавлять в конец лексера произвольный С++ код позволяет очень быстро писать разнообразные утилиты обработки текстовых файлов (логи, **.ini-файлы**), для синтаксиса которых достаточно только возможностей regexp:

```Cpp
/* sample.lex */
%option main
%%
[ \t\r\n]+  { printf("\n"); }
```
компиляция и запуск:
```shell
flex sample.lex && g++ -o sample lex.yy.c
./sample < sample.lex
```
все пробельные символы будут заменены на перевод строки:
```
/*
sample.lex
*/
%option
main
%%
[
\t\r\n]+
{
printf("\n");
}
```

Опция `main` создаст вам функцию `int main() { return yylex(); }`, либо вы сами можете написать её расширенную версию после второго `%%` маркера с вводом имён файлов и опций используя [[аргументы командной строки]] и [[#файловый ввод]] описанный далее.

## минимальный лексер

```Cpp
%{
    #include "skelex.hpp"
%}
```
```Cpp
%option noyywrap yylineno
```
||
|-|-
`noyywrap` |
[[yylineno]] | переменная с номером текущей строки
```Cpp
%%
```
```Cpp
#.*         {}              // строчные комментарии
[ \t\r\n]+  {}              // игнорировать пробелы
.           {yyerror("");}  // ошибка лексера на любой необработанный символ

```

Этот лексер умеет только выкидывать комментарии и пробельные символы, запуская для их обработки пустой С++ код `{}`. Любой другой символ вызовет [[#обработчик синтаксических ошибок]].

## обработчик синтаксических ошибок

```Cpp
/// обработчик синтаксических ошибок
extern void yyerror(string msg);
```
```Cpp
#define YYERR                                                         \
    "\n\n"                                                            \
        << yyfile << ':' << yylineno << ": " << msg << " [" << yytext \
        << "]\n\n"
```

![[файловый ввод]]
